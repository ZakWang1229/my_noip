## 分析

设 $f_{i,j}$ 表示使用前 $i$ 个字符串，拼接出长度为 $j$ 的字符串中字典序最小的字符串。那么转移很显然有 $f_{i,j} \gets \min (f_{i-1,j-|s_i|}+s_i,f_{i-1,j})$，于是我们有了个时空复杂度都为 $\mathcal O(nk^2)$ 的做法。

一个显然的优化是，我们可以用一个简单的背包预处理出 $b_{i,j}$ 表示用编号 $\in [i,n]$ 的串能不能拼出长度为 $j$ 的串。若 $b_{i+1,k-j}\neq 1$，则 $f_{i,j}$ 就完全没用了。

注意到，若两个串其中一个为另一个的前缀，我们是无法在当下区别出它们的优劣的，例如 $\mathtt {abb}$ 和 $\mathtt {ab}$，如果下一个串是 $\mathtt a$，那么前者更优，如果下一个串是 $\mathtt c$，那么后者更优。

但是，假如当前串是 $\mathtt {abb}$ 和 $\mathtt {ac}$，那么不管在 $\mathtt {ac}$ 后面接什么它都没有办法比 $\mathtt {abb}$ 更优。类似地可以推得，若两个串 $j,j’$ 使得 $f_{i,j},f_{i,j’}$ 不满足其中一个为另一个的前缀（并且它们在之后都能拼出长度为 $k$ 的串），那么我们必然能够舍弃其中任意一个而不影响最后的结果。

于是，对于每个 $i$ 的有效 dp 值 $f_{i,j}$，必然满足其为某个共同的串 $t_i$（事实上就是 $j$ 最大的有效 dp 值）的前缀，我们只需要记录这个串就可以把空间复杂度压到 $\mathcal O(nk)$.

再考虑，我们每次 dp 比较的所有串都是形如 $t_{i-1}$ 的一个前缀和 $s_i$（可能没有）拼接在一起的形式，于是我们可以预处理 Z 函数来做到 $\mathcal O(1)$ 寻找两个串第一个不同的位置，进而做到 $\mathcal O(1)$ 比较两个串。

然后做法就显而易见了，对每个 $i$ 处理时维护一个有效 dp 值的栈，按 $j$ 从小到大加入 $f_{i,j}$，每次若栈顶和 $f_{i,j}$ 不为前缀关系，则判断栈顶和 $f_{i,j}$ 谁更大，若栈顶更大那 $f_{i,j}$ 直接就没用了，否则弹栈。如此循环直到栈顶和 $f_{i,j}$ 为前缀关系或 $f_{i,j}$ 已经没用了。

这样我们就能维护出 dp 值了，时间复杂度 $\mathcal O(nk)$.